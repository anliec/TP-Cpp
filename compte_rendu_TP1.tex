\documentclass[a4paper, 12pts]{article}

\usepackage[top=3.5cm, bottom=3.5cm, left=3cm, right=3cm]{geometry}

\usepackage[T1]{fontenc}
\usepackage[utf8]{inputenc}
\usepackage[francais]{babel}
\usepackage{listings}

%\usepackage{hyperref} %pour les liens internet

%\usepackage{graphicx} %pour les images
\title{TP1: Une première classe}
\author{B3111: Edern HAUMONT et Nicolas SIX}
\date{Mercredi 21 octobre 2015}

%-----------------------------------------------------------------------------------------


\begin{document}

%\begin{titlepage}

\maketitle

%\end{titlepage}

%----------------------------------------------Title end

%\tableofcontents

%\pagebreak

%----------------------------------------------table of contents end

\section{Introduction}
\paragraph{}
La classe BoolContainer gère une collection dynamique de booléens non triée. Cette collection a une taille spécifiée à sa création, cependant elle peut être modifiée à la demande ou optimisée automatiquement.
La classe est dotée de méthodes d’affichage, d’ajout et de suppression d’items, de réunion d’une autre collection de booléens et de modification de capacité.
En interne, les booléens sont stockés dans un tableau statique de booléens. Celui-ci présente l'avantage de prendre peu de place en mémoire et de permettre un accès rapide aux éléments. Cependant, cela impose de recréer un tableau et de copier recopier tous les éléments du tableau un à un à chaque fois que sa taille est modifiée.
Les attributs et méthodes de la classe sont spécifiés ci-après.

\section{Atributs}
\paragraph{}
La classe BoolContainer utilise trois atribus privé pour gérer ses données:
\lstinputlisting[language=C++, firstline=102, lastline=104]{BoolContainer.h}
Cela lui permet de connaitre la quantiter de donnée actuelement stocker mais aussi d'avoir une zone de stockage par l'intermédiaure du pointeur.

\section{Méthodes publiques}

\subsection{Constructeur par défaut}
\lstinputlisting[language=C++, firstline=82, lastline=82]{BoolContainer.h}
\paragraph{}
Prend en parametre optionnel la taille de la nouvelle collection. La taille prise par défaut est une constante défini dans le .h de la classe.

\subsection{Constructeur avec tableau d'initialisation}
\lstinputlisting[language=C++, firstline=88, lastline=88]{BoolContainer.h}
\paragraph{}
Prend en parametre un tableau statique de booleens qui sera copie et sa taille.
\paragraph{Contrat:}
nouveauTab est de taille superieur ou égale à nouvelleTaille (si sa taille est supérieure à nouvelle taille seuls les élléments des case entre 0 et nouvelleTaille exclue seront copie dans le tableau).

\subsection{Destructeur}
\lstinputlisting[language=C++, firstline=96, lastline=96]{BoolContainer.h}
\paragraph{}
Détruit le tableau.

\subsection{Afficher}
\lstinputlisting[language=C++, firstline=29, lastline=29]{BoolContainer.h}
\paragraph{}
Peut afficher la capacite utilisée et disponible suivie du contenu du BoolContainer. Si le premier argument est vrais alors il y aura affichage d'une ligne avec les caracterisitiques du tableau. Si le segond est vrais alors il y aura affichage du contenue du tableau. Par défaut: affiche les deux bloques.

\subsection{Ajouter}
\lstinputlisting[language=C++, firstline=39, lastline=39]{BoolContainer.h}
\paragraph{}
Prend en parametre le booleen qui sera ajoute a la fin de la liste.

\subsection{Retirer}
\lstinputlisting[language=C++, firstline=45, lastline=45]{BoolContainer.h}
\paragraph{}
Prend en parametre l'index e partir auquel la suppression aura lieu et en parametre optionnel, la longueur de l'intervalle d'index sur lequel les suppressions auront lieu.

\subsection{Ajuster}
\lstinputlisting[language=C++, firstline=52, lastline=52]{BoolContainer.h}
\paragraph{}
Prend en parametre la taille de collection desirée (superieure à la taille utilisée actuellement).

\subsection{Réunir}
\lstinputlisting[language=C++, firstline=58, lastline=58]{BoolContainer.h}
\paragraph{}
Prend en parametre une autre collection de booleens qui sera ajoutee e la fin de la collection courante.


\section{Codes d'erreur}
\paragraph{}
Nous avons choisi de faire renvoyer un code entier par nos fonctions de façon à détecter plus facilement certaines erreurs d’exécution via des codes:
\begin{itemize}
	\item \lstinputlisting[language=C++, firstline=6, lastline=6]{errorCode.h}
Ce code d’erreur est renvoyé par la méthode Ajuster si la nouvelle taille demandée est inférieure à la taille actuellement utilisée par la collection.
	\item \lstinputlisting[language=C++, firstline=7, lastline=7]{errorCode.h}
Échec de redimensionnement du tableau.
	\item \lstinputlisting[language=C++, firstline=8, lastline=8]{errorCode.h}
Ce code d’erreur est renvoyé par la méthode Retirer si un ou des éléments dont on demande le retrait ne se trouvent pas dans la collection, c’est-à-dire au-delà de tailleUtilisee.
\end{itemize}


\section{Tests unitaires}

\paragraph{}
Pour des raison d'encapsulation le programme ne peut pas effecter la plupart des testes par lui même. De fait la plupart des tests se font par contrôle visuel: l'utilisateur ayent lancé le programme de test doit indiquer lui même si les testes ont réusie ou échouer.

\subsection{Test de la méthode Ajouter}
test visuel:
\paragraph{}
La fonction crée un BoolContainer vide, puis utilise la méthode Ajouter pour y insérer des éléments. La méthode Afficher est appelée. L’utilisateur n’a qu’à comparer le résultat de Afficher à ce qui était attendu.

\subsection{Test de la méthode Retirer}
test visuel:
\paragraph{}
La fonction crée un BoolContainer et le remplit. Elle supprime ensuite un élément puis un groupe d’éléments et permet à chaque fois à l’utilisateur de vérifier que les bons éléments ont été retirés.

\subsection{Test de la méthode Réunir}
test visuel:
\paragraph{}
La fonction crée deux BoolContainer. Elle les affiche. Puis elle appelle la méthode réunir sur le premier tableau avec le second comme argument. Enfin elle affiche le résultat et l’utilisateur vérifie la correspondance.

\subsection{Test d'overflow}
test automatisé:
\paragraph{}
Ce test vérifie qu'il n'y a pas de problème lors de l'insertion dans un tableau plein. Pour cela il crée un tableau de taille un. Puis ajoute des éléments un à un pour essayer de suprimer le même nombre d'éllément que celui qui a été ajouté. Le test ne vérifie pas l'intégritée des données mais permet de s'assurer que les tableaux ce remplisent dans ce cas sans perte d'éléments.
\paragraph{}
Le test étant automatiser il éffectue ses tests sur un grand nombre de tableau. Même si cela ne semble pas nécésaire, nous nous asurons ainsi d'une certaine stabliliter du procéssus sans que l'utilisateur ne puisse voire la différence.

\subsection{Test de la méthode Ajuster}
test automatisé:
\paragraph{}
Ce test génère un tableau et aplique la méthode ajuster desus. En fonction des parramètres employés le test vérifie qu'il n'y a pas de comportement imprévue: accepation d'un redimentionnement à une taille inférieur à la taille ocupé par les données ou refue d'un redimentionnement alors que le nombre de donnée le permettais.

\end{document}


















